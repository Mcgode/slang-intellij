{
    parserClass="slang.plugin.language.parser.SlangOldParser"
    parserUtilClass="slang.plugin.psi.SlangPsiUtil"

    psiClassPrefix="SlangOld"
    psiImplClassSuffix="Impl"
    psiPackage="slang.plugin.psi"
    psiImplPackage="slang.plugin.psi.impl"

    elementTypeHolderClass="slang.plugin.psi.SlangOldTypes"
    elementTypeClass="slang.plugin.psi.SlangElementType"
    tokenTypeClass="slang.plugin.psi.SlangTokenType"

    tokens=[
        LINE_COMMENT="regexp://+.*"
        MULTILINE_COMMENT="regexp:/\*([\s\S]*?)\*/[ \t\n\x0B\f\r]*"
        ADD_OP="+"
        SUB_OP="-"
        MUL_OP="*"
        DIV_OP="/"
        MOD_OP="%"
        LESS_OP="<"
        GREATER_OP=">"
        BITWISE_AND_OP="&"
        BITWISE_OR_OP="|"
        BITWISE_XOR_OP="^"
        BITWISE_NOT_OP="~"
        ADD_ASSIGN="+="
        SUB_ASSIGN="-="
        MUL_ASSIGN="*="
        DIV_ASSIGN="/="
        MOD_ASSIGN="%="
        AND_ASSIGN="&="
        OR_ASSIGN="|="
        XOR_ASSIGN="^="
        LEFT_SHIFT_ASSIGN="<<="
        RIGHT_SHIFT_ASSIGN=">>="
        // Storage types
        NAMESPACE="namespace"
        ENUM="enum"
        CLASS="class"
        STRUCT="struct"
        INTERFACE="interface"
        // Builtin types
        VOID="void"
        BOOL="bool"
        INT8="int8_t"
        INT16="int16_t"
        INT32="int"
        INT64="int64_t"
        UINT8="uint8_t"
        UINT16="uint16_t"
        UINT32="uint"
        UINT64="uint64_t"
        HALF="half"
        FLOAT="float"
        DOUBLE="double"
        // Keywords
        PRECISION="precision"
        EXPAND="expand"
        EACH="each"
        FUNCTYPE="functype"
        WHERE="where"
        // Literals
        UINT_LITERAL="regexp:(0x[\da-fA-F]+|\d+|Ob[01]+)u|U"
        INT_LITERAL="regexp:(0x[\da-fA-F]+|\d+|Ob[01]+)"
        FLOAT_LITERAL="regexp:((\d+[.]\d+)|(\d+[.])|([.]\d+))f"
        DOUBLE_LITERAL="regexp:((\d+[.]\d+)|(\d+[.])|([.]\d+))"
        BOOL_LITERAL="regexp:(true|false)"
        // Qualifiers
        CONST="const"
        IN="in"
        OUT="out"
        // Modifiers
        NO_DIFF="no_diff"
        FLAT="flat"
        // Identifiers
        IDENTIFIER="regexp:[_a-zA-Z][_a-zA-Z0-9]*"
    ]
}

file ::= base*

private base
    ::= glsl-global-declaration
    |   declaration

private glsl-global-declaration
    ::= PRECISION TODO TODO SEMICOLON // TODO: GLSL global declaration proper support (see slang/slang-parser.cpp:4867)

private declaration
    ::= declaration-modifier* declaration-content

private declaration-modifier
    ::= NO_DIFF
    |   FLAT
    |   attribute-container
//    |   IDENTIFIER // TODO: support user-defined declaration modifiers identifiers (see slang/slang-parser.cpp:1175)

private attribute-container
    ::= LEFT_BRACKET LEFT_BRACKET attributes RIGHT_BRACKET RIGHT_BRACKET
    |   LEFT_BRACKET attributes RIGHT_BRACKET

private attributes
    ::= attribute (COMMA attribute)*

private attribute
    ::= attribute-identifier ( LEFT_PAREN attribute-parameters RIGHT_PAREN )?

private attribute-identifier
    ::= SCOPE? IDENTIFIER (SCOPE IDENTIFIER)*

private attribute-parameters
    ::= attribute-parameter (COMMA attribute-parameter)*

private attribute-parameter
    ::= TODO // TODO: handle attribute parameters (see slang/slang-parser.cpp:1008)

private declaration-content
    ::= TODO_IDENTIFIER // TODO: (see slang/slang-parser.cpp:4706)
    |   SEMICOLON
    |   empty-declaration
    |   declarator-declaration

// We shouldn't be seeing an LEFT_BRACE or an LEFT_PAREN when expecting a declaration-content.
// However recovery logic may lead us here. In this case we just skip the whole `{}` block and return an empty declaration.
private empty-declaration
    ::= LEFT_BRACE TODO RIGHT_BRACE // TODO: Set up a safe skip method (see slang/slang-parser.cpp:345)
    |   LEFT_PAREN TODO RIGHT_PAREN // TODO: See above

private declarator-declaration
    ::= type-specification array-specifier* SEMICOLON?

private type-specification
    ::= simple-type-specification

private simple-type-specification
    ::= inline-type-specification
    |   TODO // TODO: Implement (see slang/slang-parser.cpp:2717)

private inline-type-specification
    ::= struct-declaration
    |   class-declaration
    |   enum-declaration
    |   prefix-expression-declaration
    |   functype-declaration


private struct-declaration
    ::= struct-header ASSIGN type-expression SEMICOLON
    |   struct-header SEMICOLON
    |   struct-header generic-constraints? declaration-body

private class-declaration
    ::= TODO // TODO: Implement (see slang/slang-parser.cpp:2682)

private enum-declaration
    ::= TODO // TODO: Implement (see slang/slang-parser.cpp:2689)

private prefix-expression-declaration
    ::= (EXPAND | EACH) prefix-expression

private prefix-expression
    ::= TODO // TODO: Implement (see slang/slang-parser.cpp:2696)

private functype-declaration
    ::= FUNCTYPE TODO // TODO: Implement (see slang/slang-parser.cpp:2707)

private struct-header
    ::= STRUCT attribute-container? COMPLETION_REQUEST? struct-name? template-specialization? inheritance-clause?

private struct-name
    ::= IDENTIFIER

private template-specialization
    ::= LESS_OP TODO GREATER_OP // TODO: Implement (see slang/slang-parser.cpp:1637)

private inheritance-clause
    ::= COLON type-expression (COMMA type-expression)*

private type-expression
    ::= postfix-type-expression type-expression-suffix

private generic-constraints
    ::= WHERE TODO // TODO: Implement (see slang/slang-parser.cpp:1654)

private declaration-body
    ::= LEFT_BRACE declaration* RIGHT_BRACE

private postfix-type-expression
    ::= atomic-type-expression postfix-type-expression-suffix

private type-expression-suffix
    ::= (BITWISE_AND_OP postfix-type-expression)*

private atomic-type-expression
    ::= type-specification

private postfix-type-expression-suffix
    ::= (array-specifier | pointer-specifier)*

private array-specifier
    ::= LEFT_BRACKET expression? RIGHT_BRACKET

private pointer-specifier
    ::= MUL_OP

private expression
    ::= TODO // TODO: Implement (see slang/slang-parser.cpp:6328)

declarator-tt
    ::= name-declarator-tt array-declarator-tt*

name-declarator-tt
    ::= IDENTIFIER

left array-declarator-tt
    ::= LEFT_BRACKET expression ? RIGHT_BRACKET


/*
file ::= base*

private base
    ::= PREDEFINED_MACROS
    |   declaration
    |   statement

statement
    ::= expression SEMICOLON
    |   SEMICOLON

expression
    ::= expression-assignment (COMMA expression-assignment)*
    |   expression-no-assignment (COMMA expression-no-assignment)*

expression-assignment
    ::= unary-expression assignment-operator expression-no-assignment
    { pin(".*")=assignment-operator }

assignment-operator
    ::= EQUALS
    |   ADD_ASSIGN
    |   SUB_ASSIGN
    |   MUL_ASSIGN
    |   DIV_ASSIGN
    |   MOD_ASSIGN
    |   AND_ASSIGN
    |   OR_ASSIGN
    |   XOR_ASSIGN
    |   LEFT_SHIFT_ASSIGN
    |   RIGHT_SHIFT_ASSIGN

expression-no-assignment
    ::= unary-expression

unary-expression
    ::= postfix-expression

postfix-expression
    ::= primary-expression

primary-expression
    ::= primary-expression-variable
    |   LEFT_PAREN expression RIGHT_PAREN
    |   literal

primary-expression-variable
    ::= IDENTIFIER

declaration
    ::= declaration-statement SEMICOLON
    |   storage-type-declaration

declaration-statement
    ::= single-declaration (COMMA variable-identifier array-specifier? (EQUALS initializer)?)*

single-declaration
    ::= full-type variable-identifier array-specifier? EQUALS initializer
    |   full-type variable-identifier array-specifier
    |   full-type variable-identifier?
    { pin(".*")=4 }

initializer
    ::= LEFT_BRACE expression* RIGHT_BRACE
    |   expression

array-specifier
    ::= LEFT_BRACKET expression? RIGHT_BRACKET

full-type
    ::=  type-qualifiers? type-specification

type-specification
    ::= scalar-type
    |   type-name

scalar-type
    ::= VOID
    |   BOOL
    |   INT8
    |   INT16
    |   INT32
    |   INT64
    |   UINT8
    |   UINT16
    |   UINT32
    |   UINT64
    |   HALF
    |   FLOAT
    |   DOUBLE

type-qualifiers
    ::= single-type-qualifier+

private single-type-qualifier
    ::= storage-qualifier

storage-qualifier
    ::= CONST | IN | OUT

variable-identifier
    ::= IDENTIFIER

type-name
    ::= IDENTIFIER
    |   USER_TYPE_NAME

literal
    ::= UINT_LITERAL
    |   INT_LITERAL
    |   FLOAT_LITERAL
    |   DOUBLE_LITERAL
    |   BOOL_LITERAL

private storage-type-declaration
    ::= namespace-declaration
    |   enum-declaration
    |   struct-declaration

namespace-declaration
    ::= NAMESPACE type-name? LEFT_BRACE base* RIGHT_BRACE

enum-declaration
    ::= (ENUM|ENUM_CLASS) type-name LEFT_BRACE enum-members? RIGHT_BRACE SEMICOLON

private enum-members
    ::= enum-member (COMMA enum-member)* COMMA?

enum-member
    ::= IDENTIFIER (EQUALS expression)?

struct-declaration
    ::= STRUCT type-name? LEFT_BRACE member-declaration* RIGHT_BRACE SEMICOLON

member-declaration
    ::= full-type variable-identifier (COLON semantic)? SEMICOLON
        { pin=2 }

semantic
    ::= IDENTIFIER

 */




