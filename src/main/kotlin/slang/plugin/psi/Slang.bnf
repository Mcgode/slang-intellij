{
    parserClass="slang.plugin.language.parser.SlangParser"
    parserUtilClass="slang.plugin.psi.SlangPsiUtil"

    psiClassPrefix="Slang"
    psiImplClassSuffix="Impl"
    psiPackage="slang.plugin.psi"
    psiImplPackage="slang.plugin.psi.impl"

    elementTypeHolderClass="slang.plugin.psi.SlangTypes"
    elementTypeClass="slang.plugin.psi.SlangElementType"
    tokenTypeClass="slang.plugin.psi.SlangTokenType"

    tokens=[
        LINE_COMMENT="regexp://+.*"
        MULTILINE_COMMENT="regexp:/\*([\s\S]*?)\*/[ \t\n\x0B\f\r]*"
        LEFT_BRACE="{"
        RIGHT_BRACE="}"
        LEFT_PAREN="("
        RIGHT_PAREN=")"
        LEFT_BRACKET="["
        RIGHT_BRACKET="]"
        SEMICOLON=";"
        COLON=":"
        EQUALS="="
        COMMA=","
        ADD_ASSIGN="+="
        SUB_ASSIGN="-="
        MUL_ASSIGN="*="
        DIV_ASSIGN="/="
        MOD_ASSIGN="%="
        AND_ASSIGN="&="
        OR_ASSIGN="|="
        XOR_ASSIGN="^="
        LEFT_SHIFT_ASSIGN="<<="
        RIGHT_SHIFT_ASSIGN=">>="
        // Storage types
        NAMESPACE="namespace"
        ENUM="enum"
        ENUM_CLASS="regexp:enum\s+class"
        CLASS="class"
        STRUCT="struct"
        INTERFACE="interface"
        // Builtin types
        VOID="void"
        BOOL="bool"
        INT8="int8_t"
        INT16="int16_t"
        INT32="int"
        INT64="int64_t"
        UINT8="uint8_t"
        UINT16="uint16_t"
        UINT32="uint"
        UINT64="uint64_t"
        HALF="half"
        FLOAT="float"
        DOUBLE="double"
        // Literals
        UINT_LITERAL="regexp:(0x[\da-fA-F]+|\d+|Ob[01]+)u|U"
        INT_LITERAL="regexp:(0x[\da-fA-F]+|\d+|Ob[01]+)"
        FLOAT_LITERAL="regexp:((\d+[.]\d+)|(\d+[.])|([.]\d+))f"
        DOUBLE_LITERAL="regexp:((\d+[.]\d+)|(\d+[.])|([.]\d+))"
        BOOL_LITERAL="regexp:(true|false)"
        // Qualifiers
        CONST="const"
        IN="in"
        OUT="out"
        // Identifiers
        IDENTIFIER="regexp:[_a-zA-Z][_a-zA-Z0-9]*"
    ]
}

file ::= base*

private base
    ::= PREDEFINED_MACROS
    |   declaration
    |   statement

statement
    ::= expression SEMICOLON
    |   SEMICOLON

expression
    ::= expression-assignment (COMMA expression-assignment)*
    |   expression-no-assignment (COMMA expression-no-assignment)*

expression-assignment
    ::= unary-expression assignment-operator expression-no-assignment
    { pin(".*")=assignment-operator }

assignment-operator
    ::= EQUALS
    |   ADD_ASSIGN
    |   SUB_ASSIGN
    |   MUL_ASSIGN
    |   DIV_ASSIGN
    |   MOD_ASSIGN
    |   AND_ASSIGN
    |   OR_ASSIGN
    |   XOR_ASSIGN
    |   LEFT_SHIFT_ASSIGN
    |   RIGHT_SHIFT_ASSIGN

expression-no-assignment
    ::= unary-expression

unary-expression
    ::= postfix-expression

postfix-expression
    ::= primary-expression

primary-expression
    ::= primary-expression-variable
    |   LEFT_PAREN expression RIGHT_PAREN
    |   literal

primary-expression-variable
    ::= IDENTIFIER

declaration
    ::= declaration-statement SEMICOLON
    |   storage-type-declaration

declaration-statement
    ::= single-declaration (COMMA variable-identifier array-specifier? (EQUALS initializer)?)*

single-declaration
    ::= full-type variable-identifier array-specifier? EQUALS initializer
    |   full-type variable-identifier array-specifier
    |   full-type variable-identifier?
    { pin(".*")=4 }

initializer
    ::= LEFT_BRACE expression* RIGHT_BRACE
    |   expression

array-specifier
    ::= LEFT_BRACKET expression? RIGHT_BRACKET

full-type
    ::=  type-qualifiers? type-specification

type-specification
    ::= scalar-type
    |   type-name

scalar-type
    ::= VOID
    |   BOOL
    |   INT8
    |   INT16
    |   INT32
    |   INT64
    |   UINT8
    |   UINT16
    |   UINT32
    |   UINT64
    |   HALF
    |   FLOAT
    |   DOUBLE

type-qualifiers
    ::= single-type-qualifier+

private single-type-qualifier
    ::= storage-qualifier

storage-qualifier
    ::= CONST | IN | OUT

variable-identifier
    ::= IDENTIFIER

type-name
    ::= IDENTIFIER
    |   USER_TYPE_NAME

literal
    ::= UINT_LITERAL
    |   INT_LITERAL
    |   FLOAT_LITERAL
    |   DOUBLE_LITERAL
    |   BOOL_LITERAL

private storage-type-declaration
    ::= namespace-declaration
    |   enum-declaration
    |   struct-declaration

namespace-declaration
    ::= NAMESPACE type-name? LEFT_BRACE base* RIGHT_BRACE

enum-declaration
    ::= (ENUM|ENUM_CLASS) type-name LEFT_BRACE enum-members? RIGHT_BRACE SEMICOLON

private enum-members
    ::= enum-member (COMMA enum-member)* COMMA?

enum-member
    ::= IDENTIFIER (EQUALS expression)?

struct-declaration
    ::= STRUCT type-name? LEFT_BRACE member-declaration* RIGHT_BRACE SEMICOLON

member-declaration
    ::= full-type variable-identifier (COLON semantic)? SEMICOLON
        { pin=2 }

semantic
    ::= IDENTIFIER




